------------------------------------------------------------
revno: 441
committer: Scott Moser <smoser@ubuntu.com>
branch nick: trunk
timestamp: Thu 2011-09-01 20:27:19 -0400
message:
  cloud-init-nonet.conf: just allow for the possibility that /var/run != /run
  
  This should not happen any time in the near future, but /var/run
  is actually legacy, so accept that it might not be there.
------------------------------------------------------------
revno: 440
committer: Scott Moser <smoser@ubuntu.com>
branch nick: trunk
timestamp: Thu 2011-09-01 11:53:23 -0400
message:
  upstart/cloud-init-nonet.conf: update comment/description
------------------------------------------------------------
revno: 439
committer: Scott Moser <smoser@ubuntu.com>
branch nick: trunk
timestamp: Thu 2011-09-01 11:10:10 -0400
message:
  DataSourceOVF: change the default instance id from nocloud to iid-dsovf
------------------------------------------------------------
revno: 438
committer: Scott Moser <smoser@ubuntu.com>
branch nick: trunk
timestamp: Thu 2011-09-01 11:07:28 -0400
message:
  DataSourceOVF do not provide a default static hostname
  
  This is the same change made in DataSourceNoCloud, but to the
  OVF DataSource.
------------------------------------------------------------
revno: 437
fixes bug(s): https://launchpad.net/bugs/832175
committer: Scott Moser <smoser@ubuntu.com>
branch nick: trunk
timestamp: Thu 2011-09-01 10:16:36 -0400
message:
  warn on failure of the hostname command when setting hostname
------------------------------------------------------------
revno: 436
committer: Scott Moser <smoser@ubuntu.com>
branch nick: trunk
timestamp: Thu 2011-09-01 10:07:05 -0400
message:
  improve DataSource's get_hostname function
  
  This allows for the chance that platform.node returned
  a fully qualified domainname.  Per its doc:
      Returns the computer's network name (which may not be fully
      qualified)
------------------------------------------------------------
revno: 435
committer: Scott Moser <smoser@ubuntu.com>
branch nick: trunk
timestamp: Wed 2011-08-31 16:35:45 -0400
message:
  remove a default 'local-hostname' value from DataSourceNoCloud
  
  If there is no local-hostname, then the base DataSource will
  make attempts to resolve it.  Having a default here meant that
  it would be taken as truth.
------------------------------------------------------------
revno: 434
committer: Scott Moser <smoser@ubuntu.com>
branch nick: trunk
timestamp: Wed 2011-08-31 16:32:03 -0400
message:
  cloud-init-nonet.conf: wait for all network interfaces to be up
  
  This continues the change in this file that intended to wait
  for all networking to be up.  The logic that was there would
  cause it to start cloud-init immediately if a single non-lo
  interface was up.
  
  This will basically just check if 'static-network-up' has occurred
  during this boot.
  
  There could be an issue if /var/run was populated from a previous
  boot, but since its really expected to be a tmpfs, can't have anything
  in it.
------------------------------------------------------------
revno: 433
committer: Scott Moser <smoser@ubuntu.com>
branch nick: trunk
timestamp: Wed 2011-08-31 15:32:37 -0400
message:
  cloudinit/DataSource.py: for default instance id, use 'iid-datasource'
  
  Previously the Ubuntu specific and confusing string "ubuntuhost" was
  used.  Use something that gives a better hint as to where it came from
  for get_instance_id()
------------------------------------------------------------
revno: 432
fixes bug(s): https://launchpad.net/bugs/434076 https://launchpad.net/bugs/833499
committer: Scott Moser <smoser@ubuntu.com>
branch nick: trunk
timestamp: Mon 2011-08-29 20:26:17 -0400
message:
  improve updating of .ssh/authorized_keys
  
  These changes update the .ssh/authorized_keys rather than simply appending
  This is preferable as ssh daemon picks the first key that is present.
  
  This fixes 2 issues where something had edited a .ssh/authorized_keys
  prior to cloud-init getting at it.
   a.) LP: #434076 a user prior to re-bundling
   b.) LP: #833499 the hypervisor
  
  If you want to enable ssh access for root user, the proper way to do it is
  with 'disable_root: False' in cloud-config.
=== modified file 'ChangeLog'
--- old/ChangeLog	2011-08-23 03:24:08 +0000
+++ new/ChangeLog	2011-09-02 00:27:19 +0000
@@ -44,6 +44,16 @@
    This was done by changing all users of util.subp to have None input unless specified
  - Add some debug info to the console when cloud-init runs.
    This is useful if debugging, IP and route information is printed to the console.
+ - change the mechanism for handling .ssh/authorized_keys, to update entries
+   rather than appending.  This ensures that the authorized_keys that are being
+   inserted actually do something (LP: #434076, LP: #833499)
+ - log warning on failure to set hostname (LP: #832175)
+ - upstart/cloud-init-nonet.conf: wait for all network interfaces to be up
+   allow for the possibility of /var/run != /run.
+ - DataSourceNoCloud, DataSourceOVF : do not provide a default hostname.
+   This way the configured hostname of the system will be used if not provided
+   by metadata (LP: #838280)
+ - DataSourceOVF: change the default instance id to 'iid-dsovf' from 'nocloud'
 
 0.6.1:
  - fix bug in fixing permission on /var/log/cloud-init.log (LP: #704509)

=== modified file 'cloudinit/CloudConfig/cc_set_hostname.py'
--- old/cloudinit/CloudConfig/cc_set_hostname.py	2011-08-03 17:06:55 +0000
+++ new/cloudinit/CloudConfig/cc_set_hostname.py	2011-09-01 14:16:36 +0000
@@ -28,11 +28,11 @@
         set_hostname(hostname, log)
     except Exception as e:
         util.logexc(log)
-        log.warn("failed to set hostname\n")
+        log.warn("failed to set hostname to %s\n", hostname)
 
     return(True)
 
 def set_hostname(hostname, log):
-    subprocess.Popen(['hostname', hostname]).communicate()
+    util.subp(['hostname', hostname])
     util.write_file("/etc/hostname","%s\n" % hostname, 0644)
     log.debug("populated /etc/hostname with %s on first boot", hostname)

=== modified file 'cloudinit/CloudConfig/cc_ssh.py'
--- old/cloudinit/CloudConfig/cc_ssh.py	2011-08-23 02:56:45 +0000
+++ new/cloudinit/CloudConfig/cc_ssh.py	2011-08-30 00:26:17 +0000
@@ -16,6 +16,7 @@
 #    You should have received a copy of the GNU General Public License
 #    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 import cloudinit.util as util
+import cloudinit.SshUtil as sshutil
 import os
 import glob
 import subprocess
@@ -86,57 +87,15 @@
 def send_ssh_keys_to_console():
     subprocess.call(('/usr/lib/cloud-init/write-ssh-key-fingerprints',))
 
-def apply_credentials(keys, user, disable_root, disable_root_opts=DISABLE_ROOT_OPTS):
+def apply_credentials(keys, user, disable_root, disable_root_opts=DISABLE_ROOT_OPTS, log=global_log):
     keys = set(keys)
     if user:
-        setup_user_keys(keys, user, '')
+        sshutil.setup_user_keys(keys, user, '', log)
  
     if disable_root:
         key_prefix = disable_root_opts.replace('$USER', user)
     else:
         key_prefix = ''
 
-    setup_user_keys(keys, 'root', key_prefix)
-
-def setup_user_keys(keys, user, key_prefix):
-    import pwd
-    saved_umask = os.umask(077)
-
-    pwent = pwd.getpwnam(user)
-
-    ssh_dir = '%s/.ssh' % pwent.pw_dir
-    if not os.path.exists(ssh_dir):
-        os.mkdir(ssh_dir)
-        os.chown(ssh_dir, pwent.pw_uid, pwent.pw_gid)
-
-    try:
-        ssh_cfg = parse_ssh_config()
-        akeys = ssh_cfg.get("AuthorizedKeysFile","%h/.ssh/authorized_keys")
-        akeys = akeys.replace("%h", pwent.pw_dir)
-        akeys = akeys.replace("%u", user)
-        authorized_keys = akeys
-    except Exception as e:
-        authorized_keys = '%s/.ssh/authorized_keys' % pwent.pw_dir
-        util.logexc(global_log)
-
-    fp = open(authorized_keys, 'a')
-    key_prefix = key_prefix.replace("\n"," ")
-    fp.write(''.join(['%s %s\n' % (key_prefix.strip(), key) for key in keys]))
-    fp.close()
-
-    os.chown(authorized_keys, pwent.pw_uid, pwent.pw_gid)
-
-    os.umask(saved_umask)
-
-def parse_ssh_config(fname="/etc/ssh/sshd_config"):
-    ret = { }
-    fp=open(fname)
-    for l in fp.readlines():
-        l = l.strip()
-        if not l or l.startswith("#"):
-            continue
-        key,val = l.split(None,1)
-        ret[key]=val
-    fp.close()
-    return(ret)
+    sshutil.setup_user_keys(keys, 'root', key_prefix, log)
 

=== modified file 'cloudinit/DataSource.py'
--- old/cloudinit/DataSource.py	2011-07-20 02:53:05 +0000
+++ new/cloudinit/DataSource.py	2011-09-01 14:07:05 +0000
@@ -94,13 +94,35 @@
 
     def get_instance_id(self):
         if 'instance-id' not in self.metadata:
-            return "ubuntuhost"
+            return "iid-datasource"
         return(self.metadata['instance-id'])
 
     def get_hostname(self, fqdn=False):
-        domain = "localdomain"
+        defdomain = "localdomain"
+        defhost = "localhost" 
+
+        domain = defdomain
         if not 'local-hostname' in self.metadata:
-            toks = [ platform.node(), domain ]
+
+            # this is somewhat questionable really.
+            # the cloud datasource was asked for a hostname
+            # and didn't have one. raising error might be more appropriate
+            # but instead, basically look up the existing hostname
+            toks = []
+            pfn = platform.node()
+
+            # platform.node says: Returns the computer's network 
+            #    name (which may not be fully qualified)
+            toks = pfn.split(".")
+            if pfn.find(".") > 0:
+                toks = pfn.split(".")
+            elif pfn:
+                toks = [ pfn, defdomain ]
+
+            if len(toks) == 0:
+                toks = [ defhost, defdomain ]
+                #log.warn("unable to find hostname, using defaults")
+
         else:
             toks = self.metadata['local-hostname'].split('.')
 

=== modified file 'cloudinit/DataSourceNoCloud.py'
--- old/cloudinit/DataSourceNoCloud.py	2011-07-20 03:17:27 +0000
+++ new/cloudinit/DataSourceNoCloud.py	2011-08-31 20:35:45 +0000
@@ -41,7 +41,6 @@
 
     def get_data(self):
         defaults = { 
-            "local-hostname" : "ubuntuhost",
             "instance-id" : "nocloud"
         }
 

=== modified file 'cloudinit/DataSourceOVF.py'
--- old/cloudinit/DataSourceOVF.py	2011-02-19 02:56:06 +0000
+++ new/cloudinit/DataSourceOVF.py	2011-09-01 15:10:10 +0000
@@ -51,8 +51,7 @@
         ud = ""
 
         defaults = { 
-            "local-hostname" : "ubuntuhost",
-            "instance-id" : "nocloud"
+            "instance-id" : "iid-dsovf"
         }
 
         (seedfile, contents) = get_ovf_env(seeddir)
@@ -109,9 +108,6 @@
         if not 'public-keys' in self.metadata: return([])
         return([self.metadata['public-keys'],])
         
-    def get_hostname(self):
-        return(self.metadata['local-hostname'])
-
     # the data sources' config_obj is a cloud-config formated
     # object that came to it from ways other than cloud-config
     # because cloud-config content would be handled elsewhere

=== added file 'cloudinit/SshUtil.py'
--- old/cloudinit/SshUtil.py	1970-01-01 00:00:00 +0000
+++ new/cloudinit/SshUtil.py	2011-08-30 00:26:17 +0000
@@ -0,0 +1,195 @@
+#!/usr/bin/python
+
+import os
+import os.path
+import cloudinit.util as util
+
+class AuthKeyEntry():
+    # lines are options, keytype, base64-encoded key, comment
+    # man page says the following which I did not understand:
+    #   The options field is optional; its presence is determined by whether
+    #   the line starts with a number or not (the options field never starts
+    #   with a number)
+    options = None
+    keytype = None
+    base64 = None
+    comment = None
+    is_comment = False
+    line_in = ""
+
+    def __init__(self, line, def_opt=None):
+        line=line.rstrip("\n\r")
+        self.line_in = line
+        if line.startswith("#") or line.strip() == "":
+            self.is_comment = True
+        else:
+            ent = line.strip()
+            toks = ent.split(None,3)
+            if len(toks) == 1:
+                self.base64 = toks[0]
+            elif len(toks) == 2:
+                (self.base64, self.comment) = toks
+            elif len(toks) == 3:
+                (self.keytype, self.base64, self.comment) = toks
+            elif len(toks) == 4:
+                i = 0
+                ent = line.strip()
+                quoted = False
+                # taken from auth_rsa_key_allowed in auth-rsa.c
+                try:
+                    while (i < len(ent) and 
+                           ((quoted) or (ent[i] not in (" ", "\t")))):
+                        curc = ent[i]
+                        nextc = ent[i + 1]
+                        if curc == "\\" and nextc == '"':
+                            i = i + 1
+                        elif curc == '"':
+                            quoted = not quoted
+                        i = i + 1
+                except IndexError as e:
+                    self.is_comment = True
+                    return()
+
+                try:
+                    self.options = ent[0:i]
+                    (self.keytype, self.base64, self.comment) = \
+                        ent[i+1:].split(None,3)
+                except ValueError as e:
+                    # we did not understand this line
+                    self.is_comment = True
+
+        if self.options == None and def_opt:
+            self.options = def_opt
+
+        return
+
+    def debug(self):
+        print("line_in=%s\ncomment: %s\noptions=%s\nkeytype=%s\nbase64=%s\ncomment=%s\n" %
+            (self.line_in, self.is_comment, self.options, self.keytype, self.base64, self.comment)),
+    def __repr__(self):
+        if self.is_comment:
+            return(self.line_in)
+        else:
+            toks = [ ]
+            for e in (self.options, self.keytype, self.base64, self.comment):
+                if e:
+                    toks.append(e)
+                
+            return(' '.join(toks))
+            
+def update_authorized_keys(fname, keys):
+    # keys is a list of AuthKeyEntries
+    # key_prefix is the prefix (options) to prepend
+    try:
+        fp = open(fname, "r")
+        lines = fp.readlines() # lines have carriage return
+        fp.close()
+    except IOError as e:
+        lines = [ ]
+
+    ka_stats = { } # keys_added status
+    for k in keys:
+        ka_stats[k] = False
+
+    to_add = []
+    for key in keys:
+        to_add.append(key)
+
+    for i in range(0,len(lines)):
+        ent = AuthKeyEntry(lines[i])
+        for k in keys:
+            if k.base64 == ent.base64 and not k.is_comment:
+                ent = k
+                try:
+                    to_add.remove(k)
+                except ValueError:
+                    pass
+        lines[i] = str(ent)
+
+    # now append any entries we did not match above
+    for key in to_add:
+        lines.append(str(key))
+
+    if len(lines) == 0:
+        return("")
+    else:
+        return('\n'.join(lines) + "\n")
+
+    
+def setup_user_keys(keys, user, key_prefix, log=None):
+    import pwd
+    saved_umask = os.umask(077)
+
+    pwent = pwd.getpwnam(user)
+
+    ssh_dir = '%s/.ssh' % pwent.pw_dir
+    if not os.path.exists(ssh_dir):
+        os.mkdir(ssh_dir)
+        os.chown(ssh_dir, pwent.pw_uid, pwent.pw_gid)
+
+    try:
+        ssh_cfg = parse_ssh_config()
+        akeys = ssh_cfg.get("AuthorizedKeysFile","%h/.ssh/authorized_keys")
+        akeys = akeys.replace("%h", pwent.pw_dir)
+        akeys = akeys.replace("%u", user)
+        authorized_keys = akeys
+    except Exception as e:
+        authorized_keys = '%s/.ssh/authorized_keys' % pwent.pw_dir
+        if log:
+            util.logexc(log)
+
+    key_entries = []
+    for k in keys:
+        ke = AuthKeyEntry(k, def_opt=key_prefix)
+        key_entries.append(ke)
+
+    content = update_authorized_keys(authorized_keys, key_entries)
+    util.write_file(authorized_keys, content, 0600)
+
+    os.chown(authorized_keys, pwent.pw_uid, pwent.pw_gid)
+
+    os.umask(saved_umask)
+
+if __name__ == "__main__":
+    import sys
+    # usage: orig_file, new_keys, [key_prefix]
+    #   prints out merged, where 'new_keys' will trump old
+    ##  example
+    ## ### begin authorized_keys ###
+    # ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAIEA28CDAGtxSucHezSKqwh1wAs39xdeZTSVmmyMcKDI5Njnd1d/Uhgj/awxP0Whep8eRSm6F+Xgwi0pH1KNPCszPvq+03K+yi3YkYkQIkVBhctK6AP/UmlVQTVmjJdEvgtrppFTjCzf16q0BT0mXX5YFV3csgm8cJn7UveKHkYjJp8= smoser-work
+    # ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEA3I7VUf2l5gSn5uavROsc5HRDpZdQueUq5ozemNSj8T7enqKHOEaFoU2VoPgGEWC9RyzSQVeyD6s7APMcE82EtmW4skVEgEGSbDc1pvxzxtchBj78hJP6Cf5TCMFSXw+Fz5rF1dR23QDbN1mkHs7adr8GW4kSWqU7Q7NDwfIrJJtO7Hi42GyXtvEONHbiRPOe8stqUly7MvUoN+5kfjBM8Qqpfl2+FNhTYWpMfYdPUnE7u536WqzFmsaqJctz3gBxH9Ex7dFtrxR4qiqEr9Qtlu3xGn7Bw07/+i1D+ey3ONkZLN+LQ714cgj8fRS4Hj29SCmXp5Kt5/82cD/VN3NtHw== smoser@brickies
+    # ### end authorized_keys ###
+    # 
+    # ### begin new_keys ###
+    # ssh-rsa nonmatch smoser@newhost
+    # ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAIEA28CDAGtxSucHezSKqwh1wAs39xdeZTSVmmyMcKDI5Njnd1d/Uhgj/awxP0Whep8eRSm6F+Xgwi0pH1KNPCszPvq+03K+yi3YkYkQIkVBhctK6AP/UmlVQTVmjJdEvgtrppFTjCzf16q0BT0mXX5YFV3csgm8cJn7UveKHkYjJp8= new_comment
+    # ### end new_keys ###
+    #
+    # Then run as:
+    #  program authorized_keys new_keys 'no-port-forwarding,command=\"echo hi world;\"'
+    def_prefix = None
+    orig_key_file = sys.argv[1]
+    new_key_file = sys.argv[2]
+    if len(sys.argv) > 3:
+        def_prefix = sys.argv[3]
+    fp = open(new_key_file)
+
+    newkeys = [ ]
+    for line in fp.readlines():
+        newkeys.append(AuthKeyEntry(line, def_prefix))
+
+    fp.close()
+    print update_authorized_keys(orig_key_file, newkeys)
+
+def parse_ssh_config(fname="/etc/ssh/sshd_config"):
+    ret = { }
+    fp=open(fname)
+    for l in fp.readlines():
+        l = l.strip()
+        if not l or l.startswith("#"):
+            continue
+        key,val = l.split(None,1)
+        ret[key]=val
+    fp.close()
+    return(ret)
+

=== modified file 'upstart/cloud-init-nonet.conf'
--- old/upstart/cloud-init-nonet.conf	2011-08-01 18:32:59 +0000
+++ new/upstart/cloud-init-nonet.conf	2011-09-02 00:27:19 +0000
@@ -1,7 +1,8 @@
 # cloud-init-no-net
 # the purpose of this job is
-#  * to block running of cloud-init until a non 'lo' interface is up
-#  * timeout if one doens't come up in a reasonable amount of time
+#  * to block running of cloud-init until all network interfaces
+#    configured in /etc/network/interfaces are up
+#  * timeout if they all do not come up in a reasonable amount of time
 start on mounted MOUNTPOINT=/ and stopped cloud-init-local
 stop on static-network-up
 task
@@ -9,8 +10,11 @@
 console output
 
 script
-   # if a non 'lo' interface is up, exit immediately
-   grep -qv '^lo' /var/run/network/ifstate >/dev/null 2>&1 && exit 0
+   # /run/network/static-network-up-emitted is written by
+   # upstart (via /etc/network/if-up.d/upstart). its presense would
+   # indicate that static-network-up has already fired.
+	EMITTED="/run/network/static-network-up-emitted"
+   [ -e "$EMITTED" -o -e "/var/$EMITTED" ] && exit 0
 
    [ -f /var/lib/cloud/instance/obj.pkl ] && exit 0
 

