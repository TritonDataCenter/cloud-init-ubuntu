------------------------------------------------------------
revno: 426
committer: Scott Moser <smoser@ubuntu.com>
branch nick: trunk
timestamp: Wed 2011-08-03 15:21:26 -0400
message:
  minor fixes to doc
------------------------------------------------------------
revno: 425
committer: Scott Moser <smoser@ubuntu.com>
branch nick: trunk
timestamp: Wed 2011-08-03 15:19:31 -0400
message:
  update ChangeLog
------------------------------------------------------------
revno: 424
committer: Scott Moser <smoser@ubuntu.com>
branch nick: trunk
timestamp: Wed 2011-08-03 14:41:41 -0400
message:
  fix incorrect logic when 'manage_etc_hosts' has a value
  
  For better or worse, 'manage_etc_hosts' means 
     "write /etc/hosts from the template"
  
  The default setting is 'False', which was not to update
  /etc/hosts at all.  Now, we're updating /etc/hosts, claiming
  the 127.0.1.1 entry as owned by cloud-init if manage_etc_hosts is
  false.
------------------------------------------------------------
revno: 423
committer: Scott Moser <smoser@ubuntu.com>
branch nick: trunk
timestamp: Wed 2011-08-03 14:37:01 -0400
message:
  remove debug statement
------------------------------------------------------------
revno: 422
committer: Scott Moser <smoser@ubuntu.com>
branch nick: trunk
timestamp: Wed 2011-08-03 13:40:07 -0400
message:
  cloudinit/util.py: fix syntax error
------------------------------------------------------------
revno: 421
committer: Scott Moser <smoser@ubuntu.com>
branch nick: trunk
timestamp: Wed 2011-08-03 13:06:55 -0400
message:
  add get_hostname_fqdn method to 'util' and use it for getting hostname
  
  This adds a method 'get_hostname_fqdn' to cloudinit.util, and then
  uses this method for getting the hostname and fqdn in places that get 
  hostname.
  
  The single place for getting it right will help.
------------------------------------------------------------
revno: 420
committer: Scott Moser <smoser@ubuntu.com>
branch nick: trunk
timestamp: Wed 2011-08-03 13:02:01 -0400
message:
  improve update_etc_hosts method in cc_update_etc_hosts
  
  This fixes a couple issues with the updating of /etc/hosts
  by the update-etc-hosts cloud-config module.
  
   * if hostname changed in the life of the instance, an additional
     "header" line would be added.
   * any comment lines like '#mycomment' would be deleted because
     they did not have 2 fields
------------------------------------------------------------
revno: 419
committer: Scott Moser <smoser@ubuntu.com>
branch nick: trunk
timestamp: Wed 2011-08-03 12:26:27 -0400
message:
  add example part-handler implementing the version 2 part-handler
------------------------------------------------------------
revno: 418
fixes bug(s): https://launchpad.net/bugs/819507
committer: Scott Moser <smoser@ubuntu.com>
branch nick: trunk
timestamp: Tue 2011-08-02 17:09:43 -0400
message:
  This fixes LP: #819507, to make consume_userdata run 'always'
  
  consume_userdata should really run always, rather than once per instance.
  
  The documentation says that boothooks were on their own for per-instance
  but since this routine was only being called once, they would only get
  called once.
  
  This  modifies the behavior to be:
     user_script: per_always
     cloud_config : per_always
     upstart_job : per_instance
     cloud_boothook: per_always
  
  In order to not break part handlers that are existing, and expect to only be
  called once per instance, this adds a 'handler_version' item in a handler
  that can indicate the version (currently 1 or 2).  If it is 2, then the
  hander will be passed the frequency (per-instance or per-always) that this
  is being run.  That way the handler can differenciate between them.
  
  This also makes 'bootcmd' run every boot.  That should be changable in
  cloud-config though, so users who dont like the behavior can modify it.
=== modified file 'ChangeLog'
--- old/ChangeLog	2011-08-01 18:32:59 +0000
+++ new/ChangeLog	2011-08-03 19:19:31 +0000
@@ -34,6 +34,10 @@
  - support for passing public and private keys to mcollective via cloud-config
  - support multiple staticly configured network devices, as long as
    all of them come up early (LP: #810044)
+ - Changes to handling user data mean that:
+   * boothooks will now run more than once as they were intended (and as bootcmd
+     commands do)
+   * cloud-config and user-scripts will be updated from user data every boot
 0.6.1:
  - fix bug in fixing permission on /var/log/cloud-init.log (LP: #704509)
  - improve comment strings in rsyslog file tools/21-cloudinit.conf

=== modified file 'cloud-init.py'
--- old/cloud-init.py	2011-06-17 15:03:49 +0000
+++ new/cloud-init.py	2011-08-02 21:09:43 +0000
@@ -140,8 +140,10 @@
 
     # parse the user data (ec2-run-userdata.py)
     try:
-        cloud.sem_and_run("consume_userdata", "once-per-instance",
-            cloud.consume_userdata,[],False)
+        ran = cloud.sem_and_run("consume_userdata", cloudinit.per_instance,
+            cloud.consume_userdata,[cloudinit.per_instance],False)
+        if not ran:
+            cloud.consume_userdata(cloudinit.per_always)
     except:
         warn("consuming user data failed!\n")
         raise

=== modified file 'cloudinit/CloudConfig/__init__.py'
--- old/cloudinit/CloudConfig/__init__.py	2011-02-19 04:29:46 +0000
+++ new/cloudinit/CloudConfig/__init__.py	2011-08-02 21:09:43 +0000
@@ -25,9 +25,9 @@
 import subprocess
 import time
 
-per_instance="once-per-instance"
-per_always="always"
-per_once="once"
+per_instance= cloudinit.per_instance
+per_always = cloudinit.per_always
+per_once = cloudinit.per_once
 
 class CloudConfig():
     cfgfile = None

=== modified file 'cloudinit/CloudConfig/cc_bootcmd.py'
--- old/cloudinit/CloudConfig/cc_bootcmd.py	2011-02-07 22:03:34 +0000
+++ new/cloudinit/CloudConfig/cc_bootcmd.py	2011-08-02 21:09:43 +0000
@@ -18,6 +18,8 @@
 import cloudinit.util as util
 import subprocess
 import tempfile
+from cloudinit.CloudConfig import per_always
+frequency = per_always
 
 def handle(name,cfg,cloud,log,args):
     if not cfg.has_key("bootcmd"):

=== modified file 'cloudinit/CloudConfig/cc_set_hostname.py'
--- old/cloudinit/CloudConfig/cc_set_hostname.py	2011-07-18 18:03:16 +0000
+++ new/cloudinit/CloudConfig/cc_set_hostname.py	2011-08-03 17:06:55 +0000
@@ -23,8 +23,8 @@
         log.debug("preserve_hostname is set. not setting hostname")
         return(True)
 
+    ( hostname, fqdn ) = util.get_hostname_fqdn(cfg, cloud)
     try:
-        hostname = util.get_cfg_option_str(cfg,"hostname",cloud.get_hostname())
         set_hostname(hostname, log)
     except Exception as e:
         util.logexc(log)

=== modified file 'cloudinit/CloudConfig/cc_update_etc_hosts.py'
--- old/cloudinit/CloudConfig/cc_update_etc_hosts.py	2011-07-20 02:53:05 +0000
+++ new/cloudinit/CloudConfig/cc_update_etc_hosts.py	2011-08-03 18:41:41 +0000
@@ -22,10 +22,10 @@
 frequency = per_always
 
 def handle(name,cfg,cloud,log,args):
-    hostname = util.get_cfg_option_str(cfg,"hostname",cloud.get_hostname())
-    fqdn = util.get_cfg_option_str(cfg,"fqdn",cloud.get_hostname(fqdn=True))
+    ( hostname, fqdn ) = util.get_hostname_fqdn(cfg, cloud)
 
-    if util.get_cfg_option_bool(cfg,"manage_etc_hosts", True):
+    use_template = util.get_cfg_option_bool(cfg,"manage_etc_hosts", False)
+    if not use_template:
         # manage_etc_hosts not true, update the 127.0.1.1 entry via update_etc_hosts
         log.debug("manage_etc_hosts is not set, checking sanity of /etc/hosts")
         update_etc_hosts(hostname, fqdn, log)
@@ -46,27 +46,30 @@
 
 def update_etc_hosts(hostname, fqdn, log):
      with open('/etc/hosts', 'r') as etchosts:
-         hosts_line = "# Added by cloud-init\n127.0.1.1\t%s %s\n" % (fqdn, hostname)
+         header = "# Added by cloud-init\n"
+         hosts_line = "127.0.1.1\t%s %s\n" % (fqdn, hostname)
          need_write = False
          need_change = True
          new_etchosts = StringIO.StringIO()
          for line in etchosts:
              split_line = [s.strip() for s in line.split()]
-             # skip over malformed /etc/hosts entries
              if len(split_line) < 2:
-                 continue
+                new_etchosts.write(line)
+                continue
+             if line == header:
+                continue
              ip, hosts = split_line[0], split_line[1:]
              if ip == "127.0.1.1":
                  if sorted([hostname, fqdn]) == sorted(hosts):
                      need_change = False
                  if need_change == True:
-                     line = hosts_line
+                     line = "%s%s" % (header, hosts_line)
                      need_change = False
                      need_write = True
              new_etchosts.write(line)
          etchosts.close()
          if need_change == True:
-             new_etchosts.write(hosts_line)
+             new_etchosts.write("%s%s" % (header, hosts_line))
              need_write = True
          if need_write == True:
              new_etcfile = open ('/etc/hosts','wb')
@@ -74,3 +77,4 @@
              new_etcfile.close()
          new_etchosts.close()
      return
+

=== modified file 'cloudinit/CloudConfig/cc_update_hostname.py'
--- old/cloudinit/CloudConfig/cc_update_hostname.py	2011-02-07 19:36:33 +0000
+++ new/cloudinit/CloudConfig/cc_update_hostname.py	2011-08-03 17:06:55 +0000
@@ -27,8 +27,8 @@
         log.debug("preserve_hostname is set. not updating hostname")
         return
 
+    ( hostname, fqdn ) = util.get_hostname_fqdn(cfg, cloud)
     try:
-        hostname = util.get_cfg_option_str(cfg,"hostname",cloud.get_hostname())
         prev ="%s/%s" % (cloud.get_cpath('data'),"previous-hostname")
         update_hostname(hostname, prev, log)
     except Exception as e:

=== modified file 'cloudinit/UserDataHandler.py'
--- old/cloudinit/UserDataHandler.py	2011-07-26 18:04:02 +0000
+++ new/cloudinit/UserDataHandler.py	2011-08-02 21:09:43 +0000
@@ -190,11 +190,10 @@
     process_includes(email.message_from_string(decomp_str(data)),parts)
     return(parts2mime(parts))
 
-# callbacks is a dictionary with:
-#  { 'content-type': handler(data,content_type,filename,payload) }
-def walk_userdata(str, callbacks, data = None):
+# callback is a function that will be called with (data, content_type, filename, payload)
+def walk_userdata(istr, callback, data = None):
     partnum = 0
-    for part in email.message_from_string(str).walk():
+    for part in email.message_from_string(istr).walk():
         # multipart/* are just containers
         if part.get_content_maintype() == 'multipart':
             continue
@@ -207,8 +206,7 @@
         if not filename:
             filename = 'part-%03d' % partnum
 
-        if callbacks.has_key(ctype):
-            callbacks[ctype](data,ctype,filename,part.get_payload())
+        callback(data, ctype, filename, part.get_payload())
 
         partnum = partnum+1
 

=== modified file 'cloudinit/__init__.py'
--- old/cloudinit/__init__.py	2011-07-20 02:53:05 +0000
+++ new/cloudinit/__init__.py	2011-08-02 21:09:43 +0000
@@ -46,6 +46,10 @@
    None : "",
 }
 
+per_instance="once-per-instance"
+per_always="always"
+per_once="once"
+
 parsed_cfgs = { }
 
 import os
@@ -63,6 +67,7 @@
 import logging.config
 import StringIO
 import glob
+import traceback
 
 class NullHandler(logging.Handler):
     def emit(self,record): pass
@@ -111,14 +116,16 @@
     ds_deps = [ DataSource.DEP_FILESYSTEM, DataSource.DEP_NETWORK ]
     datasource = None
 
+    builtin_handlers = [ ]
+
     def __init__(self, ds_deps = None, sysconfig=system_config):
-        self.part_handlers = {
-            'text/x-shellscript' : self.handle_user_script,
-            'text/cloud-config' : self.handle_cloud_config,
-            'text/upstart-job' : self.handle_upstart_job,
-            'text/part-handler' : self.handle_handler,
-            'text/cloud-boothook' : self.handle_cloud_boothook
-        }
+        self.builtin_handlers = [
+            [ 'text/x-shellscript', self.handle_user_script, per_always ],
+            [ 'text/cloud-config', self.handle_cloud_config, per_always ],
+            [ 'text/upstart-job', self.handle_upstart_job, per_instance ],
+            [ 'text/cloud-boothook', self.handle_cloud_boothook, per_always ],
+        ]
+
         if ds_deps != None:
             self.ds_deps = ds_deps
         self.sysconfig=sysconfig
@@ -249,7 +256,7 @@
         return("%s/%s.%s" % (get_cpath("sem"), name, freq))
     
     def sem_has_run(self,name,freq):
-        if freq == "always": return False
+        if freq == per_always: return False
         semfile = self.sem_getpath(name,freq)
         if os.path.exists(semfile):
             return True
@@ -265,7 +272,7 @@
             if e.errno != errno.EEXIST:
                 raise e
     
-        if os.path.exists(semfile) and freq != "always":
+        if os.path.exists(semfile) and freq != per_always:
             return False
     
         # race condition
@@ -294,7 +301,7 @@
     def sem_and_run(self,semname,freq,func,args=[],clear_on_fail=False):
         if self.sem_has_run(semname,freq):
             log.debug("%s already ran %s", semname, freq)
-            return
+            return False
         try:
             if not self.sem_acquire(semname,freq):
                 raise Exception("Failed to acquire lock on %s" % semname)
@@ -305,13 +312,15 @@
                 self.sem_clear(semname,freq)
             raise
 
+        return True
+
     # get_ipath : get the instance path for a name in pathmap
     # (/var/lib/cloud/instances/<instance>/name)<name>)
     def get_ipath(self, name=None):
         return("%s/instances/%s%s" 
                % (varlibdir,self.get_instance_id(), pathmap[name]))
 
-    def consume_userdata(self):
+    def consume_userdata(self, frequency=per_instance):
         self.get_userdata()
         data = self
 
@@ -323,63 +332,40 @@
         sys.path.insert(0,cdir)
         sys.path.insert(0,idir)
 
+        part_handlers = { }
         # add handlers in cdir
         for fname in glob.glob("%s/*.py" % cdir):
             if not os.path.isfile(fname): continue
             modname = os.path.basename(fname)[0:-3]
             try:
                 mod = __import__(modname)
-                lister = getattr(mod, "list_types")
-                handler = getattr(mod, "handle_part")
-                mtypes = lister()
-                for mtype in mtypes:
-                    self.part_handlers[mtype]=handler
-                log.debug("added handler for [%s] from %s" % (mtypes,fname))
+                handler_register(mod, part_handlers, data, frequency)
+                log.debug("added handler for [%s] from %s" % (mod.list_types(), fname))
             except:
                 log.warn("failed to initialize handler in %s" % fname)
                 util.logexc(log)
-       
-        # give callbacks opportunity to initialize
-        for ctype, func in self.part_handlers.items():
-            func(data, "__begin__",None,None)
+
+        # add the internal handers if their type hasn't been already claimed
+        for (btype, bhand, bfreq) in self.builtin_handlers:
+            if btype in part_handlers:
+                continue
+            handler_register(InternalPartHandler(bhand, [btype], bfreq),
+                part_handlers, data, frequency)
+
+        # walk the data
+        pdata = { 'handlers': part_handlers, 'handlerdir': idir,
+            'data' : data, 'frequency': frequency }
         UserDataHandler.walk_userdata(self.get_userdata(),
-            self.part_handlers, data)
+            partwalker_callback, data = pdata)
 
         # give callbacks opportunity to finalize
-        for ctype, func in self.part_handlers.items():
-            func(data,"__end__",None,None)
-
-    def handle_handler(self,data,ctype,filename,payload):
-        if ctype == "__end__": return
-        if ctype == "__begin__" :
-            self.handlercount = 0
-            return
-
-        self.handlercount=self.handlercount+1
-
-        # write content to instance's handlerdir
-        handlerdir = self.get_ipath("handlers")
-        modname  = 'part-handler-%03d' % self.handlercount
-        modfname = modname + ".py"
-        util.write_file("%s/%s" % (handlerdir,modfname), payload, 0600)
-
-        try:
-            mod = __import__(modname)
-            lister = getattr(mod, "list_types")
-            handler = getattr(mod, "handle_part")
-        except:
-            import traceback
-            traceback.print_exc(file=sys.stderr)
-            return
-
-        # - call it with '__begin__'
-        handler(data, "__begin__", None, None)
-
-        # - add it self.part_handlers
-        for mtype in lister():
-            self.part_handlers[mtype]=handler
-
-    def handle_user_script(self,data,ctype,filename,payload):
+        called = [ ]
+        for (mtype, mod) in part_handlers.iteritems():
+            if mod in called:
+                continue
+            handler_call_end(mod, data, frequency)
+
+    def handle_user_script(self,data,ctype,filename,payload, frequency):
         if ctype == "__end__": return
         if ctype == "__begin__":
             # maybe delete existing things here
@@ -390,7 +376,11 @@
         util.write_file("%s/%s" % 
             (scriptsdir,filename), util.dos2unix(payload), 0700)
 
-    def handle_upstart_job(self,data,ctype,filename,payload):
+    def handle_upstart_job(self,data,ctype,filename,payload, frequency):
+        # upstart jobs are only written on the first boot
+        if frequency != per_instance:
+            return
+
         if ctype == "__end__" or ctype == "__begin__": return
         if not filename.endswith(".conf"):
             filename=filename+".conf"
@@ -398,7 +388,7 @@
         util.write_file("%s/%s" % ("/etc/init",filename),
             util.dos2unix(payload), 0644)
 
-    def handle_cloud_config(self,data,ctype,filename,payload):
+    def handle_cloud_config(self,data,ctype,filename,payload, frequency):
         if ctype == "__begin__":
             self.cloud_config_str=""
             return
@@ -418,7 +408,7 @@
 
         self.cloud_config_str+="\n#%s\n%s" % (filename,payload)
 
-    def handle_cloud_boothook(self,data,ctype,filename,payload):
+    def handle_cloud_boothook(self,data,ctype,filename,payload, frequency):
         if ctype == "__end__": return
         if ctype == "__begin__": return
 
@@ -520,3 +510,81 @@
 
 def list_sources(cfg_list, depends):
     return(DataSource.list_sources(cfg_list,depends, ["cloudinit", "" ]))
+
+def handler_register(mod, part_handlers, data, frequency=per_instance):
+    if not hasattr(mod, "handler_version"):
+        setattr(mod, "handler_version", 1)
+
+    for mtype in mod.list_types():
+        part_handlers[mtype] = mod
+
+    handler_call_begin(mod, data, frequency)
+    return(mod)
+
+def handler_call_begin(mod, data, frequency):
+    handler_handle_part(mod, data, "__begin__", None, None, frequency)
+
+def handler_call_end(mod, data, frequency):
+    handler_handle_part(mod, data, "__end__", None, None, frequency)
+
+def handler_handle_part(mod, data, ctype, filename, payload, frequency):
+    # only add the handler if the module should run
+    modfreq = getattr(mod, "frequency", per_instance)
+    if not ( modfreq == per_always or 
+            ( frequency == per_instance and modfreq == per_instance)):
+        return
+    if mod.handler_version == 1:
+        mod.handle_part(data, ctype, filename, payload)
+    else:
+        mod.handle_part(data, ctype, filename, payload, frequency)
+
+def partwalker_handle_handler(pdata, ctype, filename, payload):
+
+    curcount = pdata['handlercount']
+    modname  = 'part-handler-%03d' % curcount
+    frequency = pdata['frequency']
+
+    modfname = modname + ".py"
+    util.write_file("%s/%s" % (pdata['handlerdir'], modfname), payload, 0600)
+
+    pdata['handlercount'] = curcount + 1
+
+    try:
+        mod = __import__(modname)
+        handler_register(mod, pdata['handlers'], pdata['data'], frequency)
+    except:
+        util.logexc(log)
+        traceback.print_exc(file=sys.stderr)
+        return
+
+def partwalker_callback(pdata, ctype, filename, payload):
+    # data here is the part_handlers array and then the data to pass through
+    if ctype == "text/part-handler":
+        if 'handlercount' not in pdata:
+            pdata['handlercount'] = 0
+        partwalker_handle_handler(pdata, ctype, filename, payload)
+        return
+    if ctype not in pdata['handlers']:
+        return
+    handler_handle_part(pdata['handlers'][ctype], pdata['data'],
+        ctype, filename, payload, pdata['frequency'])
+
+class InternalPartHandler:
+    freq = per_instance
+    mtypes = [ ]
+    handler_version = 1
+    handler = None
+    def __init__(self, handler, mtypes, frequency, version = 2):
+        self.handler = handler
+        self.mtypes = mtypes
+        self.frequency = frequency
+        self.handler_version = version
+
+    def __repr__():
+        return("InternalPartHandler: [%s]" % self.mtypes)
+
+    def list_types(self):
+        return(self.mtypes)
+
+    def handle_part(self, data, ctype, filename, payload, frequency):
+        return(self.handler(data, ctype, filename, payload, frequency))

=== modified file 'cloudinit/util.py'
--- old/cloudinit/util.py	2011-07-20 03:17:27 +0000
+++ new/cloudinit/util.py	2011-08-03 17:40:07 +0000
@@ -422,3 +422,26 @@
             raise
 
     return False
+
+def get_hostname_fqdn(cfg, cloud):
+    # return the hostname and fqdn from 'cfg'.  If not found in cfg,
+    # then fall back to data from cloud
+    if "fqdn" in cfg:
+        # user specified a fqdn.  Default hostname then is based off that
+        fqdn = cfg['fqdn']
+        hostname = get_cfg_option_str(cfg,"hostname",fqdn.split('.')[0])
+    else:
+        if "hostname" in cfg and cfg['hostname'].find('.') > 0:
+            # user specified hostname, and it had '.' in it
+            # be nice to them.  set fqdn and hostname from that
+            fqdn = cfg['hostname']
+            hostname = cfg['hostname'][:fqdn.find('.')]
+        else:
+            # no fqdn set, get fqdn from cloud. 
+            # get hostname from cfg if available otherwise cloud
+            fqdn = cloud.get_hostname(fqdn=True)
+            if "hostname" in cfg:
+                hostname = cfg['hostname']
+            else:
+                hostname = cloud.get_hostname()
+    return(hostname, fqdn)

=== modified file 'doc/examples/cloud-config.txt'
--- old/doc/examples/cloud-config.txt	2011-06-17 15:13:16 +0000
+++ new/doc/examples/cloud-config.txt	2011-08-03 19:21:26 +0000
@@ -311,10 +311,49 @@
 # set to 'False' to disable
 resize_rootfs: True
 
-# if hostname is set, cloud-init will set the system hostname 
-# appropriately to its value
-# if not set, it will set hostname from the cloud metadata
-# default: None
+## hostname and /etc/hosts management
+# cloud-init will do its best to set up a sane hostname and corresponding
+# entries in /etc/hosts.
+#
+# if you do nothing, you should get the system generally correctly
+# configured.
+#  * /etc/hostname (and thus `hostname` output) set with hostname (not fqdn)
+#  * an entry in /etc/hosts for both hostname and fqdn
+#    that are obtained from the metadata service
+#  * On each boot, the above will again be set
+#  * cloud-init generally "owns" the 127.0.1.1 entry.  The
+#    rest of the file will not be modified
+#
+# You can change the above behavior with the following config variables:
+#  Remember that these can be set in cloud-config via user-data,
+#  /etc/cloud/cloud.cfg or any file in /etc/cloud/cloud.cfg.d/
+#
+# hostname:
+#   this option will be used wherever the 'hostname' is needed
+#   simply substitute it in the description above.
+#   ** If you wish to set your hostname, set it here **
+#   default: 'hostname' as returned by the metadata service
+#       on EC2, the hostname portion of 'local-hostname' is used
+#       which is something like 'ip-10-244-170-199'
+#
+# fqdn:
+#   this option will be used wherever 'fqdn' is needed.
+#   simply substitue it in the description above.
+#   default: fqdn as returned by the metadata service.  on EC2 'hostname'
+#       is used, so this is like: ip-10-244-170-199.ec2.internal
+# 
+# manage_etc_hosts:
+#   default: false
+#   Setting this config variable to 'true' will mean that on every
+#   boot, /etc/hosts will be re-written from /etc/cloud/templates/hosts.tmpl
+#   The strings '$hostname' and '$fqdn' are replaced in the template
+#   with the appropriate values.
+#
+# preserve_hostname:
+#   default: False
+#   If this option is set to True, then /etc/hostname will never updated
+#   The default behavior is to update it if it has not been modified by
+#   the user.
 
 # final_message
 # default: cloud-init boot finished at $TIMESTAMP. Up $UPTIME seconds
@@ -423,11 +462,6 @@
 # default is False
 manual_cache_clean: False
 
-# if you wish to have /etc/hosts written from /etc/cloud/templates/hosts.tmpl
-# on a per-always basis (to account for ebs stop/start), then set
-# manage_etc_hosts to True. The default is 'False'
-manage_etc_hosts: False
-
 # When cloud-init is finished running including having run 
 # cloud_init_modules, then it will run this command.  The default
 # is to emit an upstart signal as shown below.  If the value is a

=== added file 'doc/examples/part-handler-v2.txt'
--- old/doc/examples/part-handler-v2.txt	1970-01-01 00:00:00 +0000
+++ new/doc/examples/part-handler-v2.txt	2011-08-03 16:26:27 +0000
@@ -0,0 +1,38 @@
+#part-handler
+# vi: syntax=python ts=4
+# this is an example of a version 2 part handler.
+# the differences between the initial part-handler version
+# and v2 is:
+#  * handle_part receives a 5th argument, 'frequency'
+#    frequency will be either 'always' or 'per-instance'
+#  * handler_version must be set
+#
+# A handler declaring version 2 will be called on all instance boots, with a
+# different 'frequency' argument.
+
+handler_version = 2
+
+def list_types():
+    # return a list of mime-types that are handled by this module
+    return(["text/plain", "text/go-cubs-go"])
+
+def handle_part(data,ctype,filename,payload,frequency):
+    # data: the cloudinit object
+    # ctype: '__begin__', '__end__', or the specific mime-type of the part
+    # filename: the filename for the part, or dynamically generated part if
+    #           no filename is given attribute is present
+    # payload: the content of the part (empty for begin or end)
+    # frequency: the frequency that this cloud-init run is running for
+    #            this is either 'per-instance' or 'always'.  'per-instance'
+    #            will be invoked only on the first boot.  'always' will
+    #            will be called on subsequent boots.
+    if ctype == "__begin__":
+       print "my handler is beginning, frequency=%s" % frequency
+       return
+    if ctype == "__end__":
+       print "my handler is ending, frequency=%s" % frequency
+       return
+
+    print "==== received ctype=%s filename=%s ====" % (ctype,filename)
+    print payload
+    print "==== end ctype=%s filename=%s" % (ctype, filename)

