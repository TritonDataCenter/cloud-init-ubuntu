catch up to trunk revision 227

This patch is just to catch up with trunk for cloud-init.
It is generated from trunk cloud init with:
  TAG=0.5.12
  bzr diff -p1 -r tag:${TAG} > /tmp/catchup.patch
To integrate pull in a new "catchup" patch:
  rm -Rf .pc
  ./debian/rules quilt-setup
  quilt pop -a
  cp /tmp/catchup.patch debian/patches/catchup-trunk.patch
  quilt push -a

=== modified file 'cloud-init.py'
--- old/cloud-init.py	2010-06-18 01:51:13 +0000
+++ new/cloud-init.py	2010-07-07 15:25:37 +0000
@@ -24,6 +24,7 @@
 import cloudinit.util as util
 import time
 import logging
+import errno
 
 def warn(str):
     sys.stderr.write(str)
@@ -70,9 +71,14 @@
         raise
 
     try:
-        hostname = cloud.get_hostname()
-        cloud.sem_and_run("set_hostname", "once-per-instance",
-            set_hostname, [ hostname ], False)
+        if util.get_cfg_option_bool(cloud.cfg,"preserve_hostname",False):
+            log.debug("preserve_hostname is set. not managing hostname")
+        else:
+            hostname = cloud.get_hostname()
+            cloud.sem_and_run("set_hostname", "once-per-instance",
+                set_hostname, [ hostname, log ], False)
+            cloud.sem_and_run("update_hostname", "always",
+                update_hostname, [ hostname, log ], False)
     except:
         warn("failed to set hostname\n")
 
@@ -100,11 +106,72 @@
     util.render_to_file('default-locale', '/etc/default/locale', \
         { 'locale' : locale })
 
-def set_hostname(hostname):
-    subprocess.Popen(['hostname', hostname]).communicate()
-    f=open("/etc/hostname","wb")
-    f.write("%s\n" % hostname)
-    f.close()
+# read hostname from a 'hostname' file
+# allow for comments and stripping line endings.
+# if file doesn't exist, or no contents, return default
+def read_hostname(filename, default=None):
+    try:
+        fp = open(filename,"r")
+        lines = fp.readlines()
+        fp.close()
+        for line in lines:
+            hpos = line.find("#")
+            if hpos != -1:
+                line = line[0:hpos]
+            line = line.rstrip()
+            if line:
+                return line
+    except IOError, e:
+        if e.errno == errno.ENOENT: pass
+    return default
+    
+def set_hostname(hostname, log):
+    try:
+        subprocess.Popen(['hostname', hostname]).communicate()
+        util.write_file("/etc/hostname","%s\n" % hostname, 0644)
+        log.debug("populated /etc/hostname with %s on first boot", hostname)
+    except:
+        log.error("failed to set_hostname")
+
+def update_hostname(hostname, log):
+    prev_file="%s/%s" % (cloudinit.datadir,"previous-hostname")
+    etc_file = "/etc/hostname"
+
+    hostname_prev = None
+    hostname_in_etc = None
+
+    try:
+        hostname_prev = read_hostname(prev_file)
+    except:
+        log.warn("Failed to open %s" % prev_file)
+    
+    try:
+        hostname_in_etc = read_hostname(etc_file)
+    except:
+        log.warn("Failed to open %s" % etc_file)
+
+    update_files = []
+    if not hostname_prev or hostname_prev != hostname:
+        update_files.append(prev_file)
+
+    if (not hostname_in_etc or 
+        (hostname_in_etc == hostname_prev and hostname_in_etc != hostname)):
+        update_files.append(etc_file)
+
+    try:
+        for fname in update_files:
+            util.write_file(fname,"%s\n" % hostname, 0644)
+            log.debug("wrote %s to %s" % (hostname,fname))
+    except:
+        log.warn("failed to write hostname to %s" % fname)
+
+    if hostname_in_etc and hostname_prev and hostname_in_etc != hostname_prev:
+        log.debug("%s differs from %s. assuming user maintained" %
+                  (prev_file,etc_file))
+
+    if etc_file in update_files:
+        log.debug("setting hostname to %s" % hostname)
+        subprocess.Popen(['hostname', hostname]).communicate()
 
 if __name__ == '__main__':
     main()

=== modified file 'cloud.cfg'
--- old/cloud.cfg	2010-06-18 02:06:24 +0000
+++ new/cloud.cfg	2010-07-07 15:15:10 +0000
@@ -1,3 +1,4 @@
 cloud_type: auto
 user: ubuntu
 disable_root: 1
+preserve_hostname: False

=== modified file 'cloudinit/CloudConfig/__init__.py'
--- old/cloudinit/CloudConfig/__init__.py	2010-06-18 18:14:15 +0000
+++ new/cloudinit/CloudConfig/__init__.py	2010-06-30 02:16:50 +0000
@@ -35,9 +35,12 @@
         self.cloud.get_data_source()
 
     def get_config_obj(self,cfgfile):
-        f=file(cfgfile)
-        cfg=yaml.load(f.read())
-        f.close()
+        try:
+            cfg = util.read_conf(cfgfile)
+        except:
+            cloudinit.log.critical("Failed loading of cloud config '%s'. Continuing with empty config %s\n" % cfgfile)
+            cloudinit.log.debug(traceback.format_exc() + "\n")
+            cfg = None
         if cfg is None: cfg = { }
         return(util.mergedict(cfg,self.cloud.cfg))
 

=== modified file 'cloudinit/CloudConfig/cc_apt_update_upgrade.py'
--- old/cloudinit/CloudConfig/cc_apt_update_upgrade.py	2010-06-18 19:04:55 +0000
+++ new/cloudinit/CloudConfig/cc_apt_update_upgrade.py	2010-06-21 18:34:59 +0000
@@ -19,6 +19,7 @@
 import subprocess
 import traceback
 import os
+import glob
 
 def handle(name,cfg,cloud,log,args):
     update = util.get_cfg_option_bool(cfg, 'apt_update', False)

=== modified file 'cloudinit/CloudConfig/cc_mounts.py'
--- old/cloudinit/CloudConfig/cc_mounts.py	2010-06-18 19:04:55 +0000
+++ new/cloudinit/CloudConfig/cc_mounts.py	2010-07-13 15:01:09 +0000
@@ -20,18 +20,33 @@
 import re
 import string
 
+def is_mdname(name):
+    # return true if this is a metadata service name
+    if name in [ "ami", "root", "swap" ]:
+        return True
+    # names 'ephemeral0' or 'ephemeral1'
+    # 'ebs[0-9]' appears when '--block-device-mapping sdf=snap-d4d90bbc'
+    for enumname in ( "ephemeral", "ebs" ):
+        if name.startswith(enumname) and name.find(":") == -1:
+            return True
+    return False
+
 def handle(name,cfg,cloud,log,args):
     # these are our default set of mounts
-    defmnts = [ [ "ephemeral0", "/mnt", "auto", "defaults", "0", "0" ],
+    defmnts = [ [ "ephemeral0", "/mnt", "auto", "defaults", "0", "2" ],
                 [ "swap", "none", "swap", "sw", "0", "0" ] ]
 
     # fs_spec, fs_file, fs_vfstype, fs_mntops, fs-freq, fs_passno
-    defvals = [ None, None, "auto", "defaults", "0", "0" ]
+    defvals = [ None, None, "auto", "defaults,nobootwait", "0", "2" ]
 
     cfgmnt = [ ]
     if cfg.has_key("mounts"):
         cfgmnt = cfg["mounts"]
 
+    # shortname matches 'sda', 'sda1', 'xvda', 'hda'
+    shortname_filter = r"^[x]{0,1}[shv]d[a-z][0-9]*$"
+    shortname = re.compile(shortname_filter)
+
     for i in range(len(cfgmnt)):
         # skip something that wasn't a list
         if not isinstance(cfgmnt[i],list): continue
@@ -41,24 +56,19 @@
         if cfgmnt[i][0] == "ephemeral":
             cfgmnt[i][0] = "ephemeral0"
 
-        newname = cfgmnt[i][0]
-        if not newname.startswith("/"):
+        if is_mdname(cfgmnt[i][0]):
             newname = cloud.device_name_to_device(cfgmnt[i][0])
-        if newname is not None:
-            cfgmnt[i][0] = newname
-        else:
-            # there is no good way of differenciating between
-            # a name that *couldn't* exist in the md service and
-            # one that merely didnt
-            # in order to allow user to specify 'sda3' rather
-            # than '/dev/sda3', go through some hoops
-            ok = False
-            for f in [ "/", "sd", "hd", "vd", "xvd" ]:
-                if cfgmnt[i][0].startswith(f):
-                    ok = True
-                    break
-            if not ok:
+            if not newname:
+                log.debug("ignoring nonexistant named mount %s" % cfgmnt[i][0])
                 cfgmnt[i][1] = None
+            else:
+                if newname.startswith("/"):
+                    cfgmnt[i][0] = newname
+                else:
+                    cfgmnt[i][0] = "/dev/%s" % newname
+        else:
+            if shortname.match(cfgmnt[i][0]):
+                cfgmnt[i][0] = "/dev/%s" % cfgmnt[i][0]
 
     for i in range(len(cfgmnt)):
         # fill in values with 
@@ -68,9 +78,6 @@
             elif cfgmnt[i][j] is None:
                 cfgmnt[i][j] = defvals[j]
 
-        if not cfgmnt[i][0].startswith("/"):
-            cfgmnt[i][0]="/dev/%s" % cfgmnt[i][0]
-
         # if the second entry in the list is 'None' this
         # clears all previous entries of that same 'fs_spec'
         # (fs_spec is the first field in /etc/fstab, ie, that device)
@@ -145,4 +152,4 @@
         except: log.warn("Failed to make '%s' config-mount\n",d)
 
     try: util.subp(("mount","-a"))
-    except: pass
+    except: log.warn("'mount -a' failed")

=== modified file 'cloudinit/DataSourceEc2.py'
--- old/cloudinit/DataSourceEc2.py	2010-06-18 04:42:10 +0000
+++ new/cloudinit/DataSourceEc2.py	2010-07-02 00:26:24 +0000
@@ -49,7 +49,7 @@
             self.metadata = eval(data)
             mdf.close()
 
-            cloudinit.log.debug("using seeded ec2 cache data" % self.cachedir)
+            cloudinit.log.debug("using seeded ec2 cache data in %s" % self.cachedir)
             return True
         except:
             pass

=== modified file 'cloudinit/UserDataHandler.py'
--- old/cloudinit/UserDataHandler.py	2010-06-18 04:23:25 +0000
+++ new/cloudinit/UserDataHandler.py	2010-07-01 21:05:25 +0000
@@ -65,13 +65,15 @@
         payload = part.get_payload()
 
         ctype = None
-        for str, gtype in starts_with_mappings.items():
-            if payload.startswith(str):
-                ctype = gtype
-                break
+        ctype_orig = part.get_content_type()
+        if ctype_orig == "text/plain":
+            for str, gtype in starts_with_mappings.items():
+                if payload.startswith(str):
+                    ctype = gtype
+                    break
 
         if ctype is None:
-            ctype = part.get_content_type()
+            ctype = ctype_orig
 
         if ctype == 'text/x-include-url':
             do_include(payload,parts)

=== modified file 'cloudinit/__init__.py'
--- old/cloudinit/__init__.py	2010-06-18 19:41:59 +0000
+++ new/cloudinit/__init__.py	2010-07-02 00:43:15 +0000
@@ -421,11 +421,11 @@
         if ctype == "__begin__": return
 
         filename=filename.replace(os.sep,'_')
-        prefix="#cloud-boothooks"
+        prefix="#cloud-boothook"
         dos=False
         start = 0
         if payload.startswith(prefix):
-            start = len(prefix)+1
+            start = len(prefix)
             if payload[start] == '\r':
                 start=start+1
                 dos = True

=== modified file 'doc/examples/cloud-config.txt'
--- old/doc/examples/cloud-config.txt	2010-06-18 19:41:59 +0000
+++ new/doc/examples/cloud-config.txt	2010-07-09 00:57:52 +0000
@@ -102,11 +102,15 @@
 #   written to /etc/fstab.
 # - '/dev' can be ommitted for device names that begin with: xvd, sd, hd, vd
 # - if an entry does not have all 6 fields, they will be filled in
-#   from the following: [ None, None, "auto", "defaults", "0", "0" ]
+#   from the following: [ None, None, "auto", "defaults,nobootwait", "0", "2" ]
+#
+# Note, that you should set 'nobootwait' (see man fstab) for volumes that may
+# not be attached at instance boot (or reboot)
 #
 mounts:
  - [ ephemeral0, /mnt, auto, "defaults,noexec" ]
  - [ sdc, /opt/data ]
+ - [ xvdh, /opt/data, "auto", "defaults,nobootwait", "0", "0" ]
  - [ dd, /dev/zero ]
 
 # add each entry to ~/.ssh/authorized_keys for the configured user

=== modified file 'tools/write-mime-multipart'
--- old/tools/write-mime-multipart	2010-06-18 04:23:25 +0000
+++ new/tools/write-mime-multipart	2010-07-01 14:45:36 +0000
@@ -2,8 +2,6 @@
 # largely taken from python examples
 # http://docs.python.org/library/email-examples.html
 
-"""Send the contents of a directory as a MIME message."""
-
 import os
 import sys
 import smtplib

